---
title: "Get Started Using mrgsolve"
output: learnr::tutorial
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
library(learnr)
knitr::opts_chunk$set(echo = TRUE,comment='.')
library(mrgsolve)
req <- shiny::req
```


## Introduction
This is a very short introduction to `mrgsolve`.  We will cover the 
basics of loading and working with models in `mrgsolve`.

`mrgsolve` is an `R` package for simulation from hierarchical, ordinary differential equation (ODE) based models typically employed in drug development.

`mrgsolve` is distributed as a package for `R` and utilizes an ODE-solver from `ODEPACK` which is freely-available in the public domain. We develop mrgsolve on GitHub, with input and contributions from the pharmacometrics modeling and simulation community. We welcome feature requests and bug reports on the GitHub site issue tracker.

Links:

- [mrgsolve.github.io](https://mrgsolve.github.io)
- [mrgsolve user guide](https://mrgsolve.github.io/user_guide)
- [mrgsolve on GitHub](https://github.com/metrumresearchgroup/mrgsolve)
- [Metrum Research Group](https://metrumrg.com)


## Load `mrgsolve`
```{r, message=FALSE, echo=TRUE}
library(mrgsolve)
```

I usually work with these packages as well.  Most of these will eventually
be required to run the code in this tutorial.

```{r, echo=TRUE,message=FALSE}
library(dplyr)
library(magrittr)
library(tidyr)
options(mrgsolve_mread_quiet=TRUE)
```

Here, I have also set an option so that `mrgsolve` doesn't write any messages
to the console when it is compiling a model.

## A very simple PK model

Here is a PK model that is (almost) as simple as it gets: one compartment
model with extravascular absorption:

<img width=400 src=images/simplepk.png></img>

Our goal in this lesson is to code up this model in `mrgsolve` format.  As we
work on this model, we'll learn a little about the `mrgsolve` model 
specification format as well as learning a bit about how to 
load this model into the `R` session.

In the simple PK model, we see two __compartments__ (`GUT` and `CENT`) as 
well as a handful of __parameters__ (`KA`, `CL`, and `VC`) as well as
another value computed from the `CL` and `VC` (`ke`).  

One way to specify this model in `mrgsolve` format would be:
```{c,eval=FALSE,echo=TRUE}
$PARAM CL = 1, VC = 20, KA = 1.2
$CMT GUT CENT
$ODE 
dxdt_GUT = -KA*GUT;
dxdt_CENT = KA*GUT - (CL/VC)*CENT;
```

In the model here we have a block to name and set values for parameters 
(`$PARAM`), a block to name compartments (`$CMT`) as well as a block
to specify differential equations (`$ODE`).  

We said this was *one way* to specify the model.  We have written this PK 
model using differential equations, but we also could have asked `mrgsolve`
to use algebraic equations to get the amounts in each compartment at each 
required time.  More about that in a later lesson.

<HR>
### `$PARAM` - declare and initialize model parameters
```{r,eval=FALSE,echo=TRUE}
$PARAM CL = 1, VC = 20, KA=1.2
```

* Model "parameters" with`name=value` format
* Separate by `,` or `<newline>`
* Use any `name` except for words in `mrgsolve:::reserved()`
* Values are evaluated by `R` parser 
* Multiple blocks allowed
* Use `name` anywhere in the model
* Updatable in `R` but read-only in the model specification file
    * Consider `$FIXED` if appropriate
 * Most often, you will want to match names in `$PARAM` with 
   the names in your input data sets
 

 <HR>
### `$CMT` declare model compartments
 
*  Specify __name__ and __number__ of compartments in the model
*  Use any name except for those listed in`mrgsolve:::reserved()`
*  See also  or `$INIT`
 
Example `$CMT`
```{c,eval=FALSE,echo=TRUE}
$CMT GUT CENT
```

Example `$CMT`
```{c,eval=FALSE,echo=TRUE}
$INIT GUT = 0, CENT = 10
```

<HR>
### `$ODE` write differential equations

* Every compartment __needs__ an equation
* Form: `dxdt_CMT = ratein - rateout;`
* Use `CMT` for compartment amounts, parameters, or other variables 
* This block of code gets called repeatedly so be wise


```{c,eval=FALSE,echo=TRUE}
$ODE 
dxdt_GUT  = -KA*GUT;
dxdt_CENT =  KA*GUT - (CL/VC)*CENT;
```


## Read and Load a Model

### Use `mread()` to read a model from a file

```{r,eval=FALSE,echo=TRUE}
mod <- mread("simplepk", proj)
```

*  `<model-name>`, `<project-directory>`
* `mrgsolve` assumes there is a file called `mymodel.cpp` in directory `proj`
* Parse, write `.cpp` file, compile, and load the shared object
* Returns a model object (class `mrgmod`)
     * Contains all of the basic information `mrgsolve` needs to run the model



### Use `mcode()` to write a model inline

```{r,echo=TRUE}
code <- '
$PARAM CL = 1, VC = 20, KA = 1.2
$CMT GUT CENT
$ODE 
dxdt_GUT = -KA*GUT;
dxdt_CENT = KA*GUT - (CL/VC)*CENT;
'
```


```{r,eval=FALSE}
mod <- mcode("mycode", code)
```
* `mrgsolve` writes `code` under `tempdir()`, then reads it back in
 
### `mread` versus `mcode`

For project work, we highly recommend keeping your model 
in a separate `.cpp` file and loading it via `mread`.  In the long 
run, this will maximize re-use of the model and it's probably what 
you want for large project work.  

That said, we recognize the convenience of calling `mcode` 
on your "inline" model.  And we do it frequently in this tutorial
because it makes things easier to follow.  


### `mread_cache() and `mcode_cache()`
 
* Wrappers around `mread()` and `mcode()`
* Model is cached; unless invalidated, won't need to recompile next time
* See `soloc` argument; this basically let's you build the model in the 
location of your choosing


### Set `project` to `modlib()` for internal library 

* `modlib()` returns a models directory where `mrgsolve` is installed
* Common, generic PK and PK/PD models
* Some specialized models 

```{r,eval=FALSE}
mod <- mread("pk1cmt", modlib())
```


To see a listing of models in the library
```{r,eval=FALSE,purl=FALSE}
?modlib
modlib(list=TRUE)
```


## Model overview


Run the following code and see what happens:

```{r,ex-overview,exercise=TRUE}
mod <- mread("pk2cmt", modlib())
mod
param(mod)
init(mod)
```

In the example, we see the following:

- Just printing the model object to the `R` console will give
you a basic picture of what is involved in the model
- You can see names and values of model parameters using `param()`
- You can see names and values of model compartments using `init()`
    - Note also, that `init()` shows you the compartment numbers (in parentheses)
    which will be useful when choosing which compartment to dose into
    
Next, give this code a try:
```{r,ex-overview2,exercise=TRUE}
mod <- mread("pk2cmt", modlib())
class(mod)
see(mod)
stime(mod)
as.list(mod)
```


Now, you try it out: Load the model `irm1` from the internal model library and see what is in there:

```{r,trymread,exercise=TRUE}
mod <- mread()
```

```{r,trymread-solution}
mod <- mread("irm1", modlib())
param(mod)
init(mod)
see(mod)
```

## Simulate from the model

```{r}
mod <- mread_cache("pk1cmt",modlib())
mod %>% mrgsim
```

The output from `mrgsim` is an `S4` object with some information tucked away there, but 
the bulk of the data is a data frame of simulated values.

You can see in the previous example, that you always get an `ID` column as 
well as the simulated `time`.  Then, by default, `mrgsolve` gives you all 
the compartments at every simulated time as well as all derived variables marked 
to be captured in the output.  There are ways to control what appears in the output 
(mostly to limit what this or that simulation returns) that we will discuss later.


There is a `plot` method to quickly visualize results
```{r}
mod %>% mrgsim() %>% plot()
```


## Simulate with an event object
The last simulations were a real let-down: nothing happened.  We can 
easily throw a drug dosing scenario at the model through an event object like this:

```{r}
out <- 
  mod %>%
  ev(amt=100,rate=100/50,cmt=2) %>%
  mrgsim(end=120)

plot(out)
```

Here we had an infusion lasting 50 hours into the central compartment. The `event` object
was created when we passed `mod` into the `ev` function and specified things like dose 
amount, infusion rate and the compartment where the dose is to be administered.

### What to include in `ev`

- `ID` subject ID (you can use multiple ids ... `ID=1:10`
- `time` the time when the event is supposed to happen
- `cmt` the event compartment (usually where is the dose administered)
- `amt` the dose amount
- `ii` inter-dose interval
- `addl` additional doses to administer
- `rate` use non-zero rate to give an infusion; also can use `rate=-1` or `rate=-2` to follow NONMEM behavior
- `ss` set to 1 to advance the system to steady state
- `evid` event id (1 = dose is what you use most of the time)


### Available interventions and corresponding `evid`

* Bolus dosing (`evid` 1, with `rate`==0)
* Zero order infusion (`evid` 1, with `rate` > 0)
* Other type event (`evid` 2)
    * This also forces solver reset
* Compartment reset (`evid` 3)
* Reset and dose (`evid` 4)
* Replace the amount in a specific compartment (`evid` 8)


### Try it out

Create simulations using `ev` objects

- 250 mg PO x1
- 250 mg PO every 8 hours for 3 doses __as IV bolus__
- 1000 mg IV infusion over 6 hours __into the GUT compartment__

```{r, ev-exercise, exercise=TRUE}
mod <- mread_cache("pk1cmt", modlib()) %>% update(delta=0.1,end=72)
```

```{r, ev-exercise-solution}
mod <- mread_cache("pk1cmt", modlib()) %>% update(delta=0.1,end=72)
mod %>% ev(amt=250) %>% mrgsim %>% plot
mod %>% ev(amt=250, ii=8, addl=3, cmt=2) %>% mrgsim %>% plot
mod %>% ev(amt=1000, rate = 1000/6) %>% mrgsim %>% plot
```



### Create complex dosing interventions

```{r}
e1 <- ev(amt=1000, rate=20, ii=60, addl=0, cmt=2)
e2 <- ev(amt=200, ii=12, addl=9)
e3 <- ev(amt=400, ii=24, addl=9)
e <- e1 %then% e2 %then% e3

e
```

We used the `%then%` operator to start one series of events
whenever the previous series of events ended.

```{r}
out <- mod %>% ev(e) %>% mrgsim(end=480,delta=0.1)

plot(out, CENT~.)
```

There are several different ways to combine event objects together.

## Simulate from a data set

The event objects we were using earlier were really simple data frames
that had one dosing event in each row of the data frame.  This mechanism
is provided as a convenience to allow you to quickly put a series of 
events into action.

Data sets are a similar idea, but you have more flexibility and power to 
create complicated simulations.

There are several example data sets that come with `mrgsolve`
```{r,eval=FALSE}
?exdatasets
```

We will use one of them here
```{r}
data(extran1)
head(extran1)
```

Like the event object, the data set has columns for dose `amt`, dose `time` etc.


You can simulate from this data set using the `data_set` function
```{r}
mod %>% data_set(extran1) %>% 
  mrgsim(end=168,delta=0.1) %>% plot
```

So the big difference here is that data sets allow us to simulate from a population, 
where everyone might have different dosing regimens. 

__Remember__ that data sets are just `R` data frames ... nothing special or fancy about them 
except for their column names.

### Rules for `data_set`

* An `R` `data.frame`
* Columns in \blkb{any} order
* All __numeric__; `character`, `factor`, `logical` are dropped with warning
* No missing values except in unused columns
* Required: `ID`,`time`,`cmt`
* __Either__ upper __or__ lower case:
   * `time`,`amt`,`cmt`,`ii`,`addl`,`rate`,`ss`
   * `TIME`, `AMT`, `CMT`, `II`, `ADDL`, `RATE`, `SS`
* Columns with same name as `$PARAM` will be used to update during simulation


### `expand.ev` helps to quickly create data sets

```{r}
data <- expand.ev(ID=1:4, amt=c(200,400), WT=80)
data
```

`expand.ev()` does "all combinations" of the input (like `expand.grid`).  Also,
notice that by definition each ID can have only one row in the data set

### `as_data_set` helps to quickly create multi-arm trials

```{r}
e1 <- ev(ID=1,   amt=0,   ii=24, addl=4, arm=1)
e2 <- ev(ID=1:3, amt=200, ii=12, addl=9, arm=2)
e3 <- ev(ID=1:2, amt=400, ii=24, addl=4, arm=3)

data <- as_data_set(e1,e2,e3) 
data
```

and simulate from this data set
```{r}
mod <- mread_cache("popex", modlib())
mod %>% data_set(data) %>% 
  carry_out(arm) %>%
  mrgsim(end=240,delta=0.1) %>% plot(DV~time|factor(arm))
```



### Try it out

- Using this starting code, can you modify the `exTheoph` 
data set to do a 5-hour IV infusion?

- Try dropping the observation records (`evid==0`) out 
of the data set and then simulate again

```{r,theoph-exercise,exercise=TRUE}
mod <- mread_cache("pk1cmt",modlib())
data(exTheoph)
head(exTheoph)
mod %>% data_set(exTheoph) %>% mrgsim %>% plot
```

```{r,theoph-exercise-solution}
mod <- mread_cache("pk1cmt",modlib())

data(exTheoph)

df <- exTheoph %>% mutate(cmt=2,rate = amt/5)

mod %>% data_set(df) %>% mrgsim(delta=0.1, obsaug=TRUE) %>% plot(CP~.)
```


